### Eclipse Workspace Patch 1.0
#P clearcase
Index: java/hudson/plugins/clearcase/ucm/UcmMakeBaseline.java
===================================================================
--- java/hudson/plugins/clearcase/ucm/UcmMakeBaseline.java	(revision 12694)
+++ java/hudson/plugins/clearcase/ucm/UcmMakeBaseline.java	(working copy)
@@ -1,16 +1,12 @@
 package hudson.plugins.clearcase.ucm;
 
-import groovy.lang.ParameterArray;
 import hudson.FilePath;
 import hudson.Launcher;
 import hudson.Util;
 import hudson.model.AbstractBuild;
-import hudson.model.AbstractProject;
-import hudson.model.Action;
 import hudson.model.BuildListener;
 import hudson.model.Descriptor;
 import hudson.model.Executor;
-import hudson.model.InvisibleAction;
 import hudson.model.ParameterValue;
 import hudson.model.ParametersAction;
 import hudson.model.Result;
@@ -25,6 +21,8 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 
 import org.kohsuke.stapler.StaplerRequest;
 
@@ -39,7 +37,9 @@
 
     private static final String ENV_CC_BASELINE_NAME = "CC_BASELINE_NAME";
 
-    private transient String baselineName = null;
+    private transient List<String> latestBaselines = null;
+    
+    private transient List<String> createdBaselines = null;
 
     public final static Descriptor<Publisher> DESCRIPTOR = new UcmMakeBaselineDescriptor();
 
@@ -151,7 +151,7 @@
         }
         try {
             makeBaseline(build, clearToolLauncher, filePath);
-            this.baselineName = getLatestBaselineName(clearToolLauncher,
+            this.latestBaselines = getLatestBaselineNames(clearToolLauncher,
                     filePath);
             addBuildParameter(build);
         } catch (Exception ex) {
@@ -185,17 +185,33 @@
                     launcher);
 
             if (build.getResult().equals(Result.SUCCESS)) {
-                promoteBaselineToBuiltLevel(scm.getStream(), clearToolLauncher,
-                        filePath, this.baselineName);
+            	// On success, promote all current baselines in stream
+				for (String baselineName : this.latestBaselines) {
+					promoteBaselineToBuiltLevel(scm.getStream(), clearToolLauncher,
+							filePath, baselineName);
+				}
                 if (this.recommend) {
                     recommedBaseline(scm.getStream(), clearToolLauncher,
                             filePath);
                 }
+            } else if (build.getResult().equals(Result.FAILURE)) {
+            	// On failure, demote only baselines created in this build
+            	for (String baselineName : this.createdBaselines) {
+            		// Find full baseline name from latest baselines
+            		String realBaselineName = null;
+            		for (String fullBaselineName : this.latestBaselines ) {
+            			if (fullBaselineName.startsWith(baselineName)) {
+            				realBaselineName = fullBaselineName;
+            			}
+            		}
+            		if (realBaselineName == null) {
+            			listener.getLogger().println("Couldn't find baseline name for "+baselineName);
+            		} else {
+            			demoteBaselineToRejectedLevel(scm.getStream(), clearToolLauncher,
+            					filePath, realBaselineName);
+            		}
+            	}
             }
-            if (build.getResult().equals(Result.FAILURE) || build.getResult().equals(Result.ABORTED)) {
-                demoteBaselineToRejectedLevel(scm.getStream(), clearToolLauncher,
-                        filePath, this.baselineName);
-            }
 
             if (this.lockStream && this.streamSuccessfullyLocked) {
                 unlockStream(scm.getStream(), clearToolLauncher, filePath);
@@ -287,6 +303,16 @@
             throw new Exception("Failed to make baseline, reason: "
                     + cleartoolResult);
         }
+        
+        this.createdBaselines = new ArrayList<String>();
+        
+    	Pattern pattern = Pattern.compile("Created baseline \".+?\"");
+    	Matcher matcher = pattern.matcher(cleartoolResult);
+    	while (matcher.find()) {
+    		String match = matcher.group();
+    		String newBaseline = match.substring(match.indexOf("\"")+1, match.length()-1);
+    		this.createdBaselines.add(newBaseline);
+    	}        
 
     }
 
@@ -338,7 +364,7 @@
         clearToolLauncher.run(cmd.toCommandArray(), null, null, filePath);
     }    
 
-    private String getLatestBaselineName(
+    private List<String> getLatestBaselineNames(
             HudsonClearToolLauncher clearToolLauncher, FilePath filePath)
             throws Exception {
 
@@ -346,7 +372,7 @@
 
         cmd.add("lsstream");
         cmd.add("-fmt");
-        cmd.add("%[latest_bls]CXp");
+        cmd.add("%[latest_bls]Xp");
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
 
         clearToolLauncher.run(cmd.toCommandArray(), null, baos, filePath);
@@ -354,7 +380,15 @@
         String cleartoolResult = baos.toString();
         String prefix = "baseline:";
         if (cleartoolResult != null && cleartoolResult.startsWith(prefix)) {
-            return cleartoolResult.substring(prefix.length());
+			List<String> baselineNames = new ArrayList<String>();
+			String[] baselineNamesSplit = cleartoolResult.split("baseline:");
+			for (String baselineName : baselineNamesSplit) {
+				String baselineNameTrimmed = baselineName.trim();
+				if (!baselineNameTrimmed.equals("")) {
+					baselineNames.add(baselineNameTrimmed);
+				}
+			}
+            return baselineNames;
         }
         throw new Exception("Failed to get baselinename, reason: "
                 + cleartoolResult);
